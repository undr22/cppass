### 第 8 章 IO 库

IO 库对应三个头文件：`<iostream>`、`<fstream>` 和 `<sstream>`，后两者中的类对应着继承自 `<iostream>`，如 `ifstream` 和 `istringstream` 都继承自 `istream`

IO 对象不能拷贝或赋值，所以一般以引用方式传递和返回流，另外读写一个 IO 对象会改变其状态，所以引用也不能是 `const` 的

IO 类定义了一些函数和标志，用来访问和操作流的条件状态，四种状态中：`bad` 指流已崩溃、`fail` 指 IO 操作失败、`eof` 指流到达了文件结束、`good` 指流处于未出错状态，它们各自对应一个 `iostate` 类型的 `constexpr` 值，发生对应错误时会将对应的值置位

可以将流作为条件来判断其状态：其中流的状态为 `bad`、`fail`、`eof` 时会（额外）将 `fail` 置位，所以将流用作条件的代码就等于 `!fail()`，而 `bad` 和 `eof` 只能表示特定的错误

每个输出流都有一个缓冲区，可能刷新缓冲区的原因如下：

- 程序正常结束
- 缓冲区满
- 使用操作符（如 `endl`）显示刷新缓冲区
- 使用 `unitbuf` 操作符设置接下来每次操作流后都刷新缓冲区，如 `cerr` 就默认是这种设置
- 一个输出流可能被关联到另一个流，此种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新，例如默认状态下 `cin` 和 `cerr` 都关联到 `cout`，因此读 `cin` 或写 `cerr` 都会导致 `cout` 的缓冲区被刷新

`flush` 刷新缓冲区，`endl` 换行并刷新缓冲区，`ends` 插入一个空字符然后刷新缓冲区

`unitbuf` 告诉流接下来每次写操作后都进行一次 `flush` 操作，另有 `nounitbuf` 使流恢复正常的刷新机制

**如果程序崩溃，则输出缓冲区不会被刷新**

如果一个输入流被关联到一个输出流，则任何试图从输入流读数据的操作都会先刷新关联的输出流，**交互系统通常应关联输入流和输出流**，以此确保所有输出都会在读操作前被打印出来

`tie()` 有两个重载的版本，它们都返回：如果本对象当前关联到一个输出流，则返回指向这个流的指针，否则返回空指针。两个重载版本的区别在于：一个不接受参数，另一个接受一个指向 `ostream` 的指针，第二个版本将自己关联到此 `ostream`

一旦一个文件流打开，它就保持与对应文件的关联，为了将文件流关联到另一个文件，必须先关闭已经关联的文件，另外当一个 `fstream` 对象被销毁时，`close` 会被自动调用

文件流有 6 种文件模式，每个文件流类型都定义了一个默认的文件模式，未指定文件模式时就用此默认模式：如与 `ifstream` 关联的文件默认以 `in` 模式打开

默认情况下，打开一个 `ofstream` 时（默认以 `out` 模式打开），文件的内容会被丢弃，除非同时指定 `app` 模式

补充：

- 条件状态 `P279 - P281`
- 文件模式 `P286 - P287`

### 第 9 章 顺序容器

容器有好多种，这里先说顺序容器：所有顺序容器都有快速顺序访问元素的能力，只是在不同的方面有性能折中：要么是向容器中添加或从容器中删除元素的代价，要么是非顺序访问容器中元素的代价

`vector` 是可变大小数组，除非有很明确的理由用别的，否则就用这个，支持快速随机访问，在尾部之外的地方插入或删除元素可能很慢；`deque` 双端队列，头尾插入 / 删除很快；`list` 双向链表，只支持双向顺序访问，任何位置插入 / 删除都很快；`forward_list` 单向链表，比较特殊，很多容器类的操作它都没有（但是有一些自己独有的，标准库里有这个容器主要是为了达到与最好的手写链表相当的性能……）`array` 固定大小数组，比刚才那个还特殊，一会单拎出来说；`string` 某种意义上就是字符串，作为一种容器和 `vector` 差不多，有自己的（字符串相关）特殊操作

注意：依实际需要选择容器类型。比如又需要输入时在中间位置插入元素，之后又需要随机访问元素，可以考虑先插入 `vector` 再排序，或者插入到 `list` 中再拷贝到 `vector` 里。再次重申：**不知道用啥就用 `vector`**

顺序容器几乎可以保存任意类型的元素（比如元素是另一种容器），但并不是所有的操作都能适用，比如用 `<` 操作符比较同类型容器时如果元素没有实现 `<` 那就不能比

`forward_list` 不支持递减运算符（单向链表只能往前走）

迭代器：要么指向容器中的某一元素，要么指向尾元素之后的位置，一个迭代器范围由两个属于同一容器的迭代器组成，是左闭右开区间

每个容器都定义了很多类型，如 `size_type`、`iterator`、`const_iterator` 等，除此之外还有反向迭代器（和迭代器各操作相反）等，另外还有些类型别名，如 `value_type` ，用于泛型编程

`begin` 和 `end` 操作生成指向容器中第一个元素和尾元素之后位置的迭代器，这俩玩意有很多版本：带 c 的返回 `const` 迭代器，带 r 的返回反向迭代器，如下：

```cpp
list<string> a = {"Shen", "Yuan", "CNPASS"};
auto it1 = a.begin();    // list<string>::iterator
auto it2 = a.rbegin();   // list<string>::reverse_iterator
auto it3 = a.cbegin();   // list<string>::const_iterator
auto it4 = a.crbegin();  // list<string>::const_reverse_iterator
```

另外，不以 c 开头的都是重载过的。非常量对象调用时返回普通迭代器，常量对象调用时返回 `const` 迭代器。与指针和引用类似，普通迭代器可以转换为对应的 `const` 迭代器，但是反过来不行

c 开头的版本主要是为了配合 `auto` 使用：不管对象是不是常量都返回 `const` 迭代器

所有容器类型都定义了一个默认构造函数，除 `array` 外都会创建一个指定类型的空容器

将一个新容器创建为另一个容器的拷贝有两种方法：直接拷贝整个容器，或（`array` 除外）拷贝一对迭代器指定的范围。前一种方法容器类型和元素类型必须都匹配，后一种方法容器类型无所谓，元素类型只要能转换就行，比如下面这样完全 OK：

```cpp
vector<const char*> a = {"Fuck", "C++", "grammar"};
forward_list<string> b(a.begin(), a.end());
```

顺序容器（又是除 `array` 外）还提供另一个构造函数：接受一个容器大小和一个（可选的）元素初始值。如果不提供元素初始值，则标准库会创建一个值初始化器（*注：值初始化：内置类型全是 0，类类型由类默认初始化*）

与内置数组一样，大小是 `array` 类型的一部分，所以一个默认构造的 `array` 是非空的：它包含了与其大小一样多的元素，这些元素都被默认初始化（*注：默认初始化：即变量被赋予默认值，具体是什么由变量类型决定，另外定义变量的位置也对此有影响，如函数体内的内置类型变量将不被初始化。* 对于类类型来说，每个类各自决定其初始化对象的方式，是否允许不经初始化就定义对象也由类决定：如果类允许这种行为，它将决定对象的初始值是什么）

与内置数组类型不同的是：`array` 支持拷贝和对象赋值操作（但是不能用花括号包围的值列表赋值，也不支持 `assign`）

**赋值运算符要求左右两边的运算对象有相同的类型。** 所以顺序容器（除 `array` 外）还定义了一个名为 `assign` 的成员，允许我们从一个不同但 **相容** 的类型赋值，或从容器的一个子序列赋值：`assign` 操作用参数所指定元素的拷贝替换左边容器中的所有元素

**传递给 `assign` 的迭代器不能指向调用 `assign` 的容器**

`swap` 有两个版本：成员函数和非成员函数的，由于非成员函数的版本在泛型编程中使用极广，所以最好统一 **使用非成员版本的 `swap`**

除 `array` 外（又特么是你）`swap` 不对任何元素进行拷贝 / 删除 / 插入操作，保证在常数时间内完成——元素本身并未交换，`swap` 只交换两个容器的内部数据结构——所以，除 `string` 外指向容器内元素的迭代器、引用、指针在 `swap` 后不会失效，只不过它们现在指向了 `swap` 后的另一个容器里的对应元素（指向的地址没变的意思）

`forward_list` 不支持 `size` 操作

所有容器都支持相等 / 不等运算符，除了无序关联容器外的所有容器都支持关系运算符（那四个比大小的），关系运算符两边必须是保存着相同类型元素的相同类型的容器

比较两个容器实际上是进行元素的逐对比较（与 `string` 类似，不再赘述），注意 **只有当元素类型也定义了相应的比较关系运算符时，才可以用关系运算符比较两个容器**

容器的相等 / 不等运算符是用元素的 `==` 运算符实现的，其他关系运算符是用元素的 `<` 运算符实现的

除 `array` 外所有标准库容器都可以在运行时动态添加或删除元素来改变容器大小，注意：**向一个 `vector`、`string`、`deque` 插入元素会使所有指向容器的迭代器、引用和指针失效**

除了 `array` 和 `forward_list` 每个顺序容器都支持 `push_back`

`list`、`forward_list`、`deque` 还支持 `push_front`

注意：**容器元素是拷贝**：即将一个对象插入到容器中时，事实上放进去的是对象值的一个拷贝，而非对象本身

`vector`、`deque`、`list`、`string` 还支持 `insert` 成员（`forward_list` 支持一个特殊版本：`insert_after`），可以向指定位置插入（一个范围内的）元素，返回指向被插入的第一个元素的迭代器

`emplace_front`、`emplace`、`empalce_back` 分别对应 `push_front`、`insert`、`push_back`：后三者接受元素类型的对象，并拷贝进容器中；前三者将参数传递给元素类型的构造函数，并在容器管理的内存空间中直接构造元素

每个顺序容器都有一个 `front` 成员函数，除 `forward_list` 之外的顺序容器都有一个 `back` 成员函数，这两个操作分别返回首元素和尾元素的 **引用**（注：**在容器中访问元素的成员函数，即 `front`、`back`、下标和 `at` 返回的都是引用**：`const` 的容器就返回 `const` 的引用，非 `const` 的容器就返回普通引用），**使用 `auto` 时要注意**，示例如下：

```cpp
if (!c.empty()) {
  c.front() = 42;      // 将 42 赋予 c 中的第一个元素
  auto &v = c.back();  // 获得指向最后一个元素的引用
  v = 1024;            // 改变 c 中的元素
  auto v2 = c.back();  // v2 不是一个引用，它是 c.back() 的一个拷贝
  v2 = 0;              // 未改变 c 中的元素
}
```

编译器不检查下标越界，但如果使用 `at` 成员函数，会在越界时抛出一个 `out_of_range` 异常

删除元素的成员函数并不检查其参数

**删除操作后，指向 `vector` 或 `string` 中删除点之后位置的迭代器、引用和指针都会失效**

**删除 `deque` 中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效**

`erase` 成员函数从容器中的指定位置删除（一定范围的）元素，返回指向被删除的最后一个元素之后位置的迭代器

**特殊的来了**：`forward_list` 没有 `insert`、`emplace`、`erase` 操作，而是有 `insert_after`、`emplace_after`、`erase_after`，另外它还有一个 `before_begin` 成员函数，返回一个指向首元素之前位置的 **首前迭代器**（是的 `const` 版本也有），以便于执行上述三种操作

`resize` 可以改变容器大小：增大缩小都可以。如果缩小，容器的后边的元素会被删除掉，如果增大，会将新元素添加到容器后部。一如既往的， `array` 不支持这个操作

`resize` 接受一个可选的元素值参数，用以初始化添加到容器中的元素：如果调用者未提供此参数，则执行值初始化（就是说，如果容器保存的是类类型元素，且 `resize` 向容器中添加新元素，则必须提供初始值，或元素类型必须提供一个默认构造函数）

**如果 `resize` 缩小容器，则指向被删除元素的迭代器、引用和指针失效**

**对 `vector`、`string` 或 `deque` 进行 `resize` *可能* 导致迭代器、指针和引用失效**

**注意：切记要保持迭代器有效，必须保证每次改变容器的操作之后都能正确地重新定位迭代器。这个建议对 `vector`、`string` 和 `deque` 尤其重要**

接上条，示例：如果在一个循环中插入 / 删除 `vector`、`string` 或 `deque` 中的元素，**不要缓存 `end` 返回的迭代器**

关于容器的容量管理，有这么几个相关的成员函数：`size` 指已经保存的元素的数量（下略作 ”大小“），`capacity` 指在不分配新的内存空间的前提下最多能保存多少元素（下略作 ”容量“），`reserve` 分配容量，`shrink_to_fit` 将容量缩减到与大小相当

`shrink_to_fit` 只适用于 `vector`、`string` 和 `deque`，用以要求退回不需要的内存空间，但是**具体实现可以选择忽略此请求**

`capacity` 和 `reserve` 只适用于 `vector` 和 `string`，`reserve` 不改变容器中元素的数量，它仅影响容量，而且：**只有需求大于当前容量时它才分配内存空间，且有可能给的比要的更大；否则狗屁不干，当然也不会退回内存空间。**（注：类似的，`resize` 也不影响容量）

`vector` 这玩意有高效的扩张策略，但仅在迫不得已时才分配新的内存空间，**一般来说是容量翻倍**

除了顺序容器，标准库还定义了三个顺序容器适配器：`stack`、`queue` 和 `priority_queue`（注：适配器是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另一种事物一样）

适配器可以使用一个类型参数，也可以使用两个类型参数，第二个参数用来指定适配器是由哪种容器实现的，如下：

```cpp
stack<int> stk;
stack<string, vector<string>> str_stk;
```

对于一个给定的适配器，可以使用哪些容器是有限制的：默认情况下 `stack` 和 `queue` 基于 `deque`，`priority_queue` 基于 `vector`

补充：

- `string` 特有的额外操作 `P320 - P328`

### 第 10 章 泛型算法

容器本身只定义了很少的操作，其他的都是靠标准库里的一组泛型算法，这组算法大多数定义于头文件 `algorithm` 中，可以用于容纳不同元素的不同容器类型（甚至有的不是容器类型的序列也可以，没错说的就是你，内置数组）

泛型算法使用迭代器操作实现，它们不依赖于容器，但依赖于元素类型的操作，如 `find` 运用元素类型的 `==` 运算符来完成每个元素与给定值的比较

注意：**泛型算法本身不会执行容器的操作**，它们只会运行于迭代器之上，执行迭代器的操作，由此我们可以得知：**泛型算法永远不会改变底层容器的大小**，即使改变了，也是因为使用了特殊的插入迭代器：改变容器大小的是插入迭代器，而非算法本身

有一些算法从两个序列中读取元素，这些算法并不要求元素类型或容器类型相同，只要能进行对应的操作即可

**对于那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少和第一个一样长**

如上条所述，算法不检查写操作，如果要保证算法有足够的元素空间来容纳输出数据，则需使用插入迭代器，用以向容器中插入元素。示例中使用了定义于 `iterator` 中的 `back_inserter` 函数：

```cpp
vector<int> vec;               // 空向量
auto it = back_inserter(vec);  // 通过它赋值会将元素添加到 vec 中
*it = 42;                      // vec 中现在有一个元素，值为 42
fill_n(it, 10, 0);             // 添加 10 个元素到 vec
```

拷贝（`copy`）算法接受三个迭代器，前两个表示输入范围，第三个表示目的序列的起始位置：

```cpp
int a1[] = {0, 1, 2, 3, 4};
int a2[sizeof(a1) / sizeof(*a1)];  // a2 与 a1 大小一样
// ret 指向拷贝到 a2 的尾元素之后的位置
auto ret = copy(begin(a1), end(a1), a2);  // 把 a1 的内容拷贝给 a2
```

许多算法都提供所谓的 “拷贝” 版本，它们保留原序列不变，将结果保存到其他位置：

```cpp
// 将所有值为 0 的元素改为 42
replace(ilist.begin(), ilist.end(), 0, 42);
// 下述操作后 ilist 并未改变，ivec 包含 ilist 的一份拷贝
// 只不过原来值为 42 的元素被改为 0
replace_copy(ilist.cbegin(), ilist.cend(), back_inserter(ivec), 42, 0);
```

还有一些用来排序的算法，以下是一个消除重复单词的简单示例：

```cpp
void elimDups(vector<string> &words) {
  // 按字典序排序 words，以便查找重复单词
  sort(words.begin(), words.end());
  // unique 重排输入范围，使得每个单词只出现一次
  // 排列在范围的前部，返回指向不重复区域之后一个位置的迭代器
  auto end_unique = unique(words.begin(), words.end());
  // 使用向量操作 erase 删除重复单词
  words.erase(end_unique, words.end());
}
```

算法可以定制操作，如 `sort` 算法默认使用元素类型的 `<` 运算符，但我们可以重载 `sort` 的默认行为来使其按我们需要的方式排序：`sort` 接受一个谓词作为第三个参数（*注：谓词：一个可调用的表达式，其返回结果是一个能用作条件的值。* 标准库算法使用的谓词有只接受单一参数的 **一元谓词** 和接受两个参数的 **二元谓词** 两种）

注：可调用对象有四种：函数，函数指针，重载了函数调用运算符的类，lambda 表达式

根据算法接受一元 / 二元谓词，传递给算法的谓词必须严格接受一个 / 两个参数，为回避此限制可使用 lambda 表达式：一个 lambda 表达式表示一个可调用的代码单元，可理解为一个可以定义在函数内部的未命名的内联函数。一个 lambda 表达式具有如下形式：

```cpp
[capture list] (parameter list) -> return type { function body }
```

其中，capture list（捕获列表）是一个 lambda 所在函数中定义的局部变量的列表（通常为空），后面三个和普通函数一样，除了 lambda 必须使用尾置返回

捕获列表和函数体必须要有，参数列表和返回类型可以不写。忽略参数列表就等于指定一个空参数列表，忽略返回类型时：如果函数体只有一个 return 语句，则返回类型由此推断而来，**否则返回类型为 `void`**

lambda 不能有默认参数

注意：**定义一个 lambda 时，编译器生成一个与 lambda 对应的新的（未命名的）类类型**：当向一个函数传递一个 lambda 时，同时定义了一个新类型和该类型的一个对象，传递的参数就是这个类类型的未命名对象。类似的，用 auto 定义一个用 lambda 初始化的变量时，定义了一个从 lambda 生成的类类型的对象

**默认情况下，从 lambda 生成的类都包含一个对应该 lambda 所捕获的变量的数据成员，该数据成员在 lambda 对象创建时被初始化**

关于捕获列表：一个 lambda 只有在其捕获列表中捕获一个它所在函数中的局部（非 `static`）变量，才能在函数体中使用该变量。**局部 `static` 变量和它所在函数之外声明的名字可以直接用**

lambda 的捕获也分两种：值捕获和引用捕获，用法和要点与函数传值 / 传引用一样：注意变量的生命周期，返回引用同理（注：**尽量保持 lambda 的变量捕获简单化**）

lambda 还有隐式捕获，写个 `=` 表示值捕获，`&` 表示引用捕获，示例如下：

```cpp
// sz 为隐式捕获，值捕获方式
auto wc = find_if(words.begin(), words.end(),
                  [=](const string &s) { return s.size() >= sz; });
```

还可以混合使用（干，我可算知道为什么说 C++ 是一门被过度设计的语言了）：

```cpp
void biggies(vector<string> &words, vector<string>::size_type sz,
             ostream &os = cout, char c = ' ') {
  // os 隐式捕获，引用捕获方式；c 显式捕获，值捕获方式
  for_each(words.begin(), words.end(),
           [&, c](const string &s) { os << s << c; });
  // os 显式捕获，引用捕获方式；c 隐式捕获，值捕获方式
  for_each(words.begin(), words.end(),
           [=, &os](const string &s) { os << s << c; });
}
```

混合使用隐式 / 显式捕获的时候：捕获列表的第一个元素必须是 `&` 或 `=`，此符号指定了默认捕获方式为引用或值。此外，**显式捕获的变量必须使用与隐式捕获不同的方式**

注意：上例代码中 `c` 或 `&os` 的位置事实上是一个逗号分隔的列表，包含 0 个或多个来自所在函数的变量。特别的，**隐式值捕获、显式引用捕获的情况时，引用捕获列表中的名字不能包括 `this`**

可变 lambda（可修改被捕获的变量的 lambda）分两种：值捕获的，在参数列表后边加上 `mutable`；引用捕获的，一如既往，能不能修改看它引用的是不是 `const`

再次重申：**lambda 这玩意除了单一 return 语句的可以自动推断返回类型，剩下的都默认返回 `void`，想指定返回类型得用尾置返回类型**

除了为每个容器定义的迭代器外，标准库还在 `iterator` 里定义了四种迭代器：插入迭代器，流迭代器，反向迭代器，移动迭代器

插入器：是一种迭代器适配器，接受一个容器，生成一个插入迭代器来向给定容器中添加元素

插入器有三种：`back_inserter`、`front_inserter`、`inserter`（当然了只有容器支持对应的 `push_back` 等操作你才能用……）`back_inserter` 往容器尾部插入，`front_inserter` 往容器头部插入，`inserter` 接受两个参数，第二个是个迭代器，它把元素插入到此迭代器之前的位置

**注意：`front_inserter` 的行为和另外两个不一样：往容器的首元素之前再插入一个元素，原来那个就不再是容器的首元素了，所以 `front_inserter` 生成的插入迭代器会将元素的插入顺序反过来，而另外两个则不会**

`iostream` 类型不是容器，但标准库定义了可以用于这类 IO 类型对象的迭代器，用法差不太多，有个小细节在于：`istream_iterator<T> end;` 可以直接读取类型为 T 的 `istream_iterator` 迭代器用于表示尾后位置，`ostream_iterator` 则没有这玩意，但可以 `ostream_iterator<T> out (os, d);`，其中 `d` 指向一个空字符结尾的字符数组（就是 C 风格字符串），在每个值后面都输出一个 `d`

反向迭代器：就是反着来的迭代器……也有那一大堆 c 或 r 开头的版本，但 **反向迭代器只能由既支持 `++` 又支持 `--` 的迭代器定义而来，所以 `forward_list` 和流迭代器没有对应的反向迭代器**

反向迭代器真的是反着走的……这么设计主要是为了直接把反向迭代器丢到算法里就能得到相反的结果，但是 **注意反向迭代器的 `rbegin` 到 `rend` 也是左闭右开区间**，所以它们和迭代器并不是一一对应，而是错开一位的。另外由于走向相反，**搭配迭代器使用的时候需要调用 `base` 成员函数来将其转换为对应的普通迭代器**（这个时候不用考虑错一位的问题）

特殊的：对于两个链表类型 `list` 和 `forward_list`，它们定义了独有的 `sort`、`merge`、`reverse` 和 `unique`（理由是通用版本的算法用于链表时代价太高，于是实现了性能更好的链表版本），此外还定义了链表特有（其他容器没有）的 `splice` 算法

链表特定算法与通用算法的区别在于：链表版本会改变底层的容器，如 `remove` 会删除（而不是覆盖）指定的元素；`unique` 会删除第二个和后继的重复元素；`merge` 和 `splice` 则会销毁其参数：来自两个链表中的元素仍然存在，但它们都已在同一链表中

补充：

- 参数绑定 `P354 - P357`
- `iostream` 迭代器 `P359 - P362`
- 泛型算法结构 `P365 - P369`

### 第 11 章 关联容器

关联容器按 3 个维度分成 8 种：是一个 `map` 或 `set`，`map` 中的元素是键值对，`set` 里只有关键字（以下略作键）；允许或不允许重复键，允许重复的容器的名字中都包含单词 `multi`；按顺序或不按顺序保存元素，其中无序容器都以 `unordered` 开头，并使用哈希函数组织元素

`map` 和 `multimap` 定义在头文件 `<map>` 中，`unordered_map` 和 `unordered_multimap` 定义在头文件 `<unordered_map>` 中，那四种 `set` 类似

关联容器不支持顺序容器那种位置相关的操作（比如 `push_back` 之类的）

关联容器的迭代器都是双向的

关联容器对其关键字类型有一些限制：对于四种有序容器来说，关键字类型必须定义元素的比较方法，默认情况下标准库使用关键字类型的 `<` 运算符来比较两个关键字；无序容器下面另写

接上条，插一嘴：传递给排序算法的可调用对象也得满足和关联容器中关键字一样的类型要求

可以提供自己定义的操作来代替关键字上的 `<` 运算符：所提供的操作必须在关键字类型上定义一个 *严格弱序*，但是这玩意解释起来太麻烦了就理解成小于等于就行了，或者，**在实际编程中，如果一个类型定义了 “行为正常” 的 `<` 运算符，则它可以用作有序关联容器的关键字类型**

用来组织一个容器中元素的操作的类型也是该容器类型的一部分，要在定义关联容器类型时提供此操作的类型，如下例所示：

```cpp
struct Book {
  int isbn;
};

bool compareBook(const Book &lhs, const Book &rhs) {
  return lhs.isbn < rhs.isbn;
}

multiset<Book, decltype(compareBook) *> bookstore(compareBook);
// 注：decltype() 返回实际类型，加上 * 来获取指针类型
//   后面的函数名字会自动转换成指针，当然写 &compareBook 也是一样的
```

`pair` 这个类型：定义在头文件 `<utility>` 中，保存两个数据成员。与容器类似，`pair` 是一个用来生成特定类型的模板，定义一个 `pair` 时要提供两个类型名（不要求一样），其数据成员具有对应的类型，**`pair` 的默认构造函数对其数据成员进行值初始化**

`.first` 和 `.second` 分别返回一个 `pair` 的第一个 / 第二个（公有）数据成员

`pair` 的大小关系按字典序，依赖元素的 `<` 运算符来实现：当 `p1.first < p2.first`，或 `!(p1.first < p2.first) && p1.second < p2.second` 时，`p1 < p2` 为 `true`

当 `first` 和 `second` 成员分别相等时，两个 `pair` 相等

`make_pair` 可用来生成 `pair` 对象，作函数返回值时亦可对返回值进行列表初始化，如下：

```cpp
pair<string, int> process(vector<string> &v) {
  // 处理 v

  if (!v.empty()) {
    return {v.back(), v.back().size()};  // 列表初始化
    // return pair<string, int>(v.back(), v.back().size());
    // return make_pair(v.back(), v.back().size());
    // 以上 3 种写法等价
  } else {
    return pair<string, int>();  // 隐式构造返回值
  }
}
```

关联容器有三种额外的类型别名：`key_type`（键的类型），`mapped_type`（值的类型，四种 `map` 才有），`value_type`（对 `set` 来说，和 `key_type` 一样；对 `map` 来说，为 `pair<const key_type, mapped_type>`，注：由于我们不能改变一个元素的关键字，所以这些 `pair` 的关键字部分是 `const` 的）

解引用一个关联容器迭代器时，会得到一个类型为容器的 `value_type` 的值的引用，**再次强调：那四种 `map` 的 `value_type` 是一个 `pair` ，我们可以改变 `pair` 的值，但是不能改变关键字成员的值**

四种 `set` 的迭代器是 `const` 的：不管是 `iterator` 类型还是 `const_iterator` 类型，都只允许只读访问 `set` 中的元素，即 `set` 中的键也是 `const` 的

关联容器也支持 `begin` 和 `end` 操作

迭代器按关键字升序遍历有序关联容器

一般不对关联容器使用泛型算法，因为键是 `const` 意味着不能将关联容器传递给修改或重排元素的算法（所以顶多也就是用用 `copy`）

关联容器有一个名为 `find` 的成员，它通过一个给定的关键字直接获取元素，相比于顺序查找的泛型 `find` 算法要快很多

关联容器也有 `insert` 和 `emplace` 操作，和顺序容器的差不多不细写了

**注意：向四种 `map` 中进行 `insert` 操作时，元素类型是 `pair`**

**特殊的：对于非 `multi` 的关联容器，添加单一元素的 `insert`（或 `emplace`，下略）返回一个 `pair`**，其 `first` 成员是一个迭代器，指向具有给定关键字的元素，`second` 成员是一个 `bool` 值，支出元素是插入成功还是已经存在于容器中：如果键已存在，则 `insert` 什么也不做，那个 `bool` 值是 `false`，如果键不存在，那就插入，那个 `bool` 值是 `true`

关联容器三个版本的 `erase` 也跟顺序容器的差不多不细写了（好耶），但关联容器还提供一个额外的 `erase`，这个得写（不好耶）：它接受一个 `key_type` 参数，删除所有匹配给定键的元素（如果存在的话），返回实际删除的元素的数量（也就是说对非 `multi` 的关联容器执行这个操作总返回 0 或 1）

`map` 和 `unordered_map` 提供下标运算符和一个对应的 `at` 函数（四种 `set` 没有是因为没有值，另外两种 `map` 没有是因为一个键可能对应多个值）

先说 `at`：带参数检查，键不存在就抛出一个 `out_of_range` 异常

**`map` 和 `unordered_map` 的下标运算符有两个特殊的地方：其一是如果键不存在，那就插入一个新的进去**（所以只能对非 `const` 的 `map` 或 `unordered_map` 使用下标操作）；**其二是它返回的类型和迭代器解引用出来的类型不一样**（对其他支持下标运算符的容器来说是一样的）：在这里，解引用迭代器返回一个 `value_type` 对象，而下标运算符返回一个 `mapped_type` 对象

关联容器提供多个查找一个指定元素的方法，最简单的两个是 `find` 和 `count`（对 `multi` 的关联容器，`count` 会做计数工作，所以如果无需计数还是用 `find`），如下：

```cpp
set<int> iset = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
iset.find(1);    // 返回一个迭代器，指向 key == 1 的元素
iset.find(11);   // 返回一个迭代器，其值等于 iset.end()
iset.count(1);   // 返回 1
iset.count(11);  // 返回 0
```

由于 `map` 和 `unordered_map` 的下标运算符有严重的副作用，所以如果想查找键值对而不想改变该 `map` 和 `unordered_map`，应该使用 `find`：

```cpp
if (word_count.find("foobar") == word_count.end())
  cout << "foobar is not in the map" << endl;
```

**如果一个 `multimap` 或 `multiset` 中有多个元素具有给定关键字，那么这些元素在容器中会相邻存储（无序版本的那两个也是）**

基于上条，我们有：`lower_bound(k)`，返回一个迭代器，指向第一个关键字不小于 k 的元素，`upper_bound(k)`，返回一个迭代器，指向第一个关键字大于 k 的元素，`equal_range(k)`，返回一个迭代器 `pair`，表示关键字等于 k 的元素的范围，若 k 不存在，则 `pair` 的两个成员都等于 `end()`

四种无序容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的 `==` 运算符

无序容器在存储上组织为一组桶，每个桶保存零或多个元素，无序容器使用一个哈希函数将元素映射到桶。另外如果容器允许重复键，则具有相同键的元素会在一个桶里。无序容器还提供了一组管理桶的函数

无序容器对元素的键类型要求很特殊：无序容器使用键的 `==` 运算符来比较元素，还使用一个 `hash<key_type>` 类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了 `hash` 模板，还为 *一些* 标准库类型（`string` 和智能指针）定义了 `hash`，因此我们可以定义关键字是内置类型、`string` 和智能指针的无序容器，但 **不能直接定义键类型是自定义类类型的无序容器**：不能直接使用 `hash` 模板，而必须提供自己的 `hash` 模板版本（见笔记第 III 部分的模板特例化）

接上条：类似于为有序容器重载键类型的默认比较操作，也可以提供函数来代替 `==` 运算符和哈希值计算函数，如下：

```cpp
struct Book {
  int isbn;
};

size_t hasher(const Book &book) { return hash<int>()(book.isbn); }

bool areSameBook(const Book &lhs, const Book &rhs) {
  return lhs.isbn == rhs.isbn;
}

using Book_multiset =
    unordered_multiset<Book, decltype(hasher) *, decltype(areSameBook) *>;

Book_multiset bookstore(42, hasher, areSameBook);
```

接上条：如果类定义了 `==` 运算符，可以只重载哈希函数

补充：

- 严格弱序 `P378`
- 访问元素 `P388 - P391`
- 无序容器管理操作 `P395`

### 第 12 章 动态内存

**静态内存** 保存局部 `static` 对象、类 `static` 数据成员和定义在任何函数之外的变量；**栈内存** 保存定义在函数内的非 `static` 对象。分配在静态内存或栈内存中的对象由编译器自动创建和销毁

对于栈对象，仅在其定义的程序块运行时才存在：`static` 对象在使用之前分配，在程序结束时销毁

**自由空间** 或 **堆** 用来动态存储对象，即那些在程序运行时分配的对象，它们的生命周期由程序控制，就是说不再使用后要显式地销毁它们

程序使用动态内存一般出于以下三种原因之一：程序不知道自己需要使用多少对象（比如容器）；程序不知道所需对象的准确类型（比如 OOP 的时候）；程序需要在多个对象间共享数据

C++ 中动态内存的管理由一对运算符完成：`new` 和 `delete`（注意这俩玩意是运算符），`new` 在堆上开辟内存并构造对象，返回一个指向该对象的指针，`delete` 接受一个动态对象的指针，销毁该对象并释放与之关联的内存

堆上分配的内存是无名的，因此 `new` 无法为其分配的对象命名（所以才返回指针）

默认情况下动态分配的对象是默认初始化的（在这里，内置类型或组合类型的对象的值是未定义的，类类型对象用默认构造函数初始化）

接上条，可以直接初始化 / 传统构造（使用圆括号）/ 列表初始化（使用花括号）一个动态分配的对象，也可以进行值初始化（在类型名后跟一对空括号）

接上条，如果我们提供了一个括号包围的初始化器，那就可以用 `auto` 来推断类型（括号内仅有单一初始化器时才行）

接上条，可以用 `new` 分配 `const` 对象，此 `const` 对象必须初始化，而且（深呼吸——除了一个定义了默认构造函数的类类型的 `const` 动态对象可以隐式初始化外）必须显式初始化，`new` 返回一个指向 `const` 的指针（底层 `const` 指针）

上面几条的示例来啦：

```cpp
string *ps = new string;  // 默认初始化为空 string
int *pi = new int;        // pi 指向一个未初始化的 int

string *ps2 = new string();  // 值初始化为空 string
int *pi2 = new int();        // 值初始化为 0

int *pi3 = new int(1024);  // 直接初始化，pi2 指向的对象的值为 1024
string *ps3 = new string(10, '9');  // 构造，*ps2 为 "9999999999"
vector<int> *pv = new vector<int>{0, 1, 2, 3, 4};  // 列表初始化

auto p1 = new auto(obj);  // 行，p 指向一个与 obj 同类型的对象
                          //   该对象用 obj 初始化
auto p2 = new auto {a, b, c};  // 不行，括号中只能有单个初始化器

const int *pci = new const int(1024);  // 分配并初始化一个 const int
const string *pcs = new const string;  // 分配并默认初始化一个 const 的空 string
```

如果内存耗尽，那 `new` 就会失败，默认情况下如果 `new` 不能分配要求的内存空间，就会抛出一个 `bad_alloc` 类型的异常

接上条，可以向 `new` 传递额外的参数来（这种形式的 `new` 称为 *定位 `new`*）阻止其抛出异常，示例代码如下（代码中传递给 `new` 的是一个由标准库定义的名为 `nothrow` 的对象，`bad_alloc` 和 `nothrow` 都定义在头文件 `<new>` 中）：

```cpp
int *p1 = new int;  // 如果分配失败，new 抛出 std::bad_alloc
int *p2 = new (nothrow) int;  // 如果分配失败，new 返回一个空指针
```

**传递给 `delete` 的指针必须指向动态分配的内存，或是一个空指针**：释放一块并非由 `new` 分配的内存，或将相同的指针值释放多次，其行为未定义

由内置指针（而非智能指针，一会写）管理的动态内存在被显式释放前会一直存在

使用 `new` 和 `delete` 管理动态内存有三个常见的问题：忘了 `delete`（就是内存泄漏）；使用已经被释放的对象（释放内存后将指针置空有时会有帮助）；同一块内存释放了两次（可能会破坏自由空间）

另外，`delete` 一个指针后，指针虽然已经无效，但有可能其仍保留着（已经被释放的）动态内存的地址，这就是所谓的 **空悬指针**

更难搞的是有时候两根指针指向同一块动态内存，而 `delete` 其中一个后另一个忘了（或者根本就超难找）……

于是，标准库提供两种智能指针来管理动态对象，它们的行为类似于常规指针，区别在于它们负责自动释放所指的对象：`shared_ptr` 允许多个指针指向同一个对象，`unique_ptr` “独占” 所指的对象

另有一种名为 `weak_ptr` 的伴随类，它是一种弱引用，指向 `shared_ptr` 所管理的对象

以上 3 种类型都定义在头文件 `<memory>` 中

智能指针也是模板，默认初始化的智能指针中保存着一个空指针

标准库里有一个 `make_shared` 函数，用于动态分配一个对象 *并初始化* 它，返回一个指向此对象的 `shared_ptr`，这玩意也定义在头文件 `<memory>` 中

使用 `make_shared` 也得给出想要创建对象的类型，然后 `make_shared` 用其参数来构造给定类型的对象（类似顺序容器的 `emplace` 成员），如果不传递参数就进行值初始化，如下：

```cpp
shared_ptr<int> pi = make_shared<int>(42);
shared_ptr<string> ps = make_shared<string>(10, '9');
auto pi2 = make_shared<int>();
```

每个 `shared_ptr` 都有一个关联的计数器（引用计数），拷贝它（用一个 `shared_ptr` 初始化另一个 `shard_ptr`、或者传参、返回之类的）的时候引用计数会递增，为它赋予新值或销毁它的时候引用计数会递减

一个 `shared_ptr` 的计数器变为 0 时，它会自动销毁自己管理的对象（通过调用析构函数），然后释放相关联的内存

**注意：如果将 `shared_ptr` 放于一个容器中，而之后不再需要全部元素，记得用 `erase` 删除那些不再需要的元素**

可以使用 `new` 返回的指针来初始化智能指针，但接受指针参数的智能指针构造函数是 `explicit` 的，所以不能将一个内置指针隐式转换为一个智能指针，而必须使用直接初始化形式来初始化一个智能指针，如下：

```cpp
shared_ptr<int> p1 = new int(1024);  // 不行
shared_ptr<int> p2(new int(1024));   // 行，直接初始化
```

智能指针可以不指向动态内存（因为智能指针默认使用 `delete` 释放它所关联的对象），但是此时必须提供自己的操作来替代 `delete`

**使用内置指针来访问智能指针负责的对象是危险行为！** 因为我们无法知道对象何时会被销毁

智能指针类型定义了一个名为 `get` 的函数，它返回一个内置指针，指向智能指针管理的对象。**注意：此函数仅为不能使用智能指针的代码设计，切勿 `delete` 这个 `get` 返回的指针**

**注意：永远不要用 `get` 初始化另一个智能指针或为另一个智能指针赋值**

`shared_ptr` 有几个独有的操作，如下：

```cpp
shared_ptr<T> p(q);  // p 管理内置指针 q 所指的对象
                     //   q 必须指向 new 分配的内存，且能转换成 T* 类型
shared_ptr<T> p(u);  // p 从 unique_ptr u 那里接管了对象的所有权，将 u 置空
shared_ptr<T> p(q, d);   // p 接管内置指针 q 所指对象的所有权
                         //   q 必须能转换成 T* 类型
                         //   p 将使用可调用对象 d 来代替 delete
shared_ptr<T> p2(q, d);  // p 是 shared_ptr p2 的拷贝
                         // p 将用可调用对象 d 来代替 delete

p.use_count();  // 返回与 p 共享对象的智能指针数量（可能很慢，用于调试）
p.unique();  // 若 p.use_count() 为 1，则返回 true，否则返回 false

p.reset();  // 若 p 是唯一指向其对象的 shared_ptr，reset 会释放此对象
p.reset(q);  // 若传递了可选的参数内置指针 q，会令 p 指向 q，否则将 p 置空
p.reset(q, d);  // 若还传递了参数 d，会调用 d 而不是 delete 来释放 q
```

即使程序块过早结束（比如抛出了异常），智能指针类也能确保在内存不再需要时将资源释放

总结一下，**智能指针避坑简易指南**：

- 不使用相同的内置指针初始化（或 `reset`）多个智能指针
- 不 `delete` `get()` 返回的指针
- 不使用 `get()` 初始化或 `reset` 另一个智能指针
- 如果使用了 `get()` 返回的指针，要注意最后一个对应的智能指针销毁后，这根指针就无效了
- 如果使用智能指针管理的资源不是 `new` 分配的内存，那要传递给它一个删除器

某个时刻只能有一个 `unique_ptr` 指向一个给定对象，当 `unique_ptr` 被销毁时，它所指向的对象也被销毁

与 `shared_ptr` 不同，*没有* 一个类似 `make_shared` 的东西返回一个 `unique_ptr`，所以定义一个 `unique_ptr` 时，得绑定到一个 `new` 返回的指针上：同样的，也必须直接初始化

`unique_ptr` 不支持普通的拷贝或赋值操作

接上条，有个例外：可以拷贝或赋值一个将要被销毁的 `unique_ptr`，比如从函数里返回的时候

`unique_ptr` 有一个 `release` 操作，`u.release()` 使 u 放弃对指针的控制权（而非释放所指的对象），返回指针，并将 u 置空

接上条， `release` 返回的指针常用来初始化 / 赋值另一个智能指针，如果没有，那我们就要负责资源的释放

`unique_ptr` 也可以重载默认的删除器（默认的就是 `delete`），但方式与 `shared_ptr` 不同，因为重载删除器会影响到 `unique_ptr` 类型如何构造（或 `reset`）该类型的对象，语法如下：

```cpp
unique_ptr<objT, delT> p(new objT, fcn);
// 注：p 指向一个类型为 objT 的对象，并使用一个类型为 delT 的对象释放 objT 对象
//   它会调用一个名为 fcn 的 delT 类型对象
```

`weak_ptr` 不控制所指向对象的生存期，它指向由一个 **`shared_ptr`** 管理的对象

将一个 `weak_ptr` 绑定到一个 `shared_ptr` 不会改变后者的引用计数

一旦最后一个指向对象的 `shared_ptr` 被销毁，即使有 `weak_ptr` 指向对象，对象也会被释放

这里有一些 `weak_ptr` 的常用操作：

```cpp
w.use_count();  // 与 w 共享对象的 shared_ptr 的数量
w.expired();    // 若 w.use_count() 为 0，返回 true，否则返回 false
w.lock();       // 如果 w.expired() 为 true，返回一个空 shared_ptr
                //   否则返回一个指向 w 的对象的 shared_ptr
```

注意：由于对象可能不存在，我们 **不能使用 `weak_ptr` 直接访问对象**，而必须调用 `lock` 来检查 `weak_ptr` 指向的对象是否仍然存在，如下：

```cpp
auto p = make_shared<int>(42);
weak_ptr<int> wp(p);  // wp 弱共享 p，p 的引用计数未改变

if (shared_ptr<int> np = wp.lock()) {
  // 在 if 中，np 与 p 共享对象
}
```

C++ 语言和标准库提供了两种一次分配一个动态对象数组的方法：C++ 语言定义了另一种 `new` 表达式语法；标准库中有一个名为 `allocator` 的类，允许将分配和初始化分离

写着太麻烦了还是看代码吧……

```cpp
// 调用 get_size 确定分配多少个 int
int *pia = new int[get_size()];  // pia 指向第一个 int
// 注：方括号中的大小必须是整形，但不必是常量

// 使用表示数组类型的类型别名来分配数组时
//   new 表达式中就不需要方括号了（在编译器看来还是有的）
typedef int arrT[42];
int *p42 = new arrT;
```

**注意：动态数组不是数组类型**，因此不能对动态数组调用 `begin` 或 `end`，也不能用范围 `for` 语句来处理（所谓的）动态数组中的元素

动态数组的初始化规则与分配单一对象的 `new` 类似，区别在于可以提供一个元素初始化器的花括号列表：如果初始化器数目小于元素数目，剩下的元素进行值初始化；如果大了，那就不分配任何内存，抛出一个类型为 `bad_array_new_length` 的异常

注意：虽然可以用空括号对动态数组中的元素进行值初始化，但不能在括号中给出初始化器（当然也就意味着不能用 `auto` 分配数组）

注意：**动态分配一个空数组是合法的**。此时 `new` 返回一个合法的非空指针，并保证与 `new` 返回的其他任何指针都不相同。此指针不能解引用

释放动态数组要是用一种特殊形式的 `delete`，还是写着麻烦直接代码：

```cpp
delete p;     // p 必须指向一个动态分配的对象或为空
delete[] pa;  // pa 必须指向一个动态分配的数组或为空

// 使用类型别名的情况……
typedef int arrT[42];
int *p42 = new arrT;
delete[] p42;  // ……也得有方括号
```

这个版本的 `delete` 按逆序销毁元素（没错，从最后一个开始），并释放对应的内存

注意：这两个版本的 `new` 和 `delete` 只能对应使用，交叉使用将导致未定义行为

标准库提供了一个可以管理 `new` 分配的数组的 `unique_ptr` 版本，不能使用点和箭头成员运算符，但可以使用下标运算符；但不能用 `shared_ptr` 管理动态数组，除非提供自定义的删除器（因为 `shared_ptr` 默认用 `delete` 销毁它指向的对象），另外 `shared_ptr` 未定义下标运算符，智能指针也不支持指针算数运算，所以想访问数组中的元素得先 `get`……麻烦，代码：

```cpp
unique_ptr<int[]> up(new int[10]);
for (size_t i = 0; i != 10; ++i) up[i] = i;
up.release();  // 自动调用 delete[] 销毁其指针

shared_ptr<int> sp(new int[10], [](int *p) { delete[] p; });
for (size_t i = 0; i != 10; ++i) *(sp.get() + i) = i;
sp.reset(); // 使用我们提供的 lambda 释放数组，它使用 delete[]
```

温习一下：`new` 干两件事：内存分配和对象构造，`delete` 也干两件事：对象析构和内存释放。所以有时候需要分配一大块内存，最好使用 `allocator` 类按需构造来避免不必要的开销

接上条，其实 `allocator` 类还有一个使用场景：没有默认构造函数的类不能动态分配数组……

`allocator` 类定义在头文件 `<memory>` 里，也是个模板类，`allocator` 对象分配的内存是未构造的，它会根据给定的对象类型来确定恰当的内存大小和对齐位置

麻，码：

```cpp
allocator<string> alloc;           // 可以分配 string 的 allocator 对象
auto const p = alloc.allocate(5);  // 分配 5 个初始化的 string

// construct 成员函数接受一个指针和零或多个额外参数
//   在指定位置构造一个元素，额外参数用来初始化构造对象
auto q = p;                     // q 指向最后构造元素之后的位置
alloc.construct(q++);           // *q 为空字符串
alloc.construct(q++, 10, 'c');  // *q 为 "cccccccccc"
alloc.construct(q++, "hi");     // *q 为 "hi"

// 不能在未构造对象时就使用原始内存！
cout << *p << endl;  // 行
cout << *q << endl;  // 不行：q 指向未构造的内存

// destroy 可以销毁 **已构造** 的元素
//   它接受一个指针，对指向的对象执行析构函数
while (q != p) alloc.destroy(--q);

// 元素被销毁后，就可以重新使用这部分内存，或通过 deallocate 归还给系统
//   传递给 deallocate 的指针不能为空，它必须指向 allocate 分配的内存
//   传递给 deallocate 的大小参数必须与 allocate 分配时的大小一致
alloc.deallocate(p, 5);
```

`allocator` 类还有两个伴随算法（各有两个版本，都在头文件 `<memory>` 里），可以在未初始化的内存中创建对象（行为类似 `copy` 和 `fill`，但事实上都是在指定位置构造元素），简单示例：

```cpp
vector<int> vi{0, 1, 2, 3, 4};
allocator<int> alloc;

// 分配比 vi 中元素所占空间大一倍的动态内存
auto p = alloc.allocate(vi.size() * 2);

// 通过拷贝 vi 中的元素来构造从 p 开始的元素
auto q = uninitialized_copy(vi.begin(), vi.end(), p);
// 注：两个 copy 算法的目的位置迭代器必须指向未构造的内存
//   它们返回一个指针，指向最后构造元素之后的位置

// 将剩余元素初始化为 42；
uninitialized_fill_n(q, vi.size(), 42);
// 注：两个填充算法指向目的位置的指针不必指向未构造的内存

// 我实在是搞不明白他们为什么要把这些函数和类名起得又臭又长……
//   （参数设置也不敢恭维……）
```

补充：

- 智能指针和异常 `P415 - P417`
- `weak_ptr` `P420 - P422`
- `allocator` 算法 `P429`