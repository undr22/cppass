### 第 8 章 IO 库

IO 库对应三个头文件：`<iostream>`、`<fstream>` 和 `<sstream>`，后两者中的类对应着继承自 `<iostream>`，如 `ifstream` 和 `istringstream` 都继承自 `istream`

IO 对象不能拷贝或赋值，所以一般以引用方式传递和返回流，另外读写一个 IO 对象会改变其状态，所以引用也不能是 `const` 的

IO 类定义了一些函数和标志，用来访问和操作流的条件状态，四种状态中：`bad` 指流已崩溃、`fail` 指 IO 操作失败、`eof` 指流到达了文件结束、`good` 指流处于未出错状态，它们各自对应一个 `iostate` 类型的 `constexpr` 值，发生对应错误时会将对应的值置位

可以将流作为条件来判断其状态：其中流的状态为 `bad`、`fail`、`eof` 时会（额外）将 `fail` 置位，所以将流用作条件的代码就等于 `!fail()`，而 `bad` 和 `eof` 只能表示特定的错误

每个输出流都有一个缓冲区，可能刷新缓冲区的原因如下：

- 程序正常结束
- 缓冲区满
- 使用操作符（如 `endl`）显示刷新缓冲区
- 使用 `unitbuf` 操作符设置接下来每次操作流后都刷新缓冲区，如 `cerr` 就默认是这种设置
- 一个输出流可能被关联到另一个流，此种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新，例如默认状态下 `cin` 和 `cerr` 都关联到 `cout`，因此读 `cin` 或写 `cerr` 都会导致 `cout` 的缓冲区被刷新

`flush` 刷新缓冲区，`endl` 换行并刷新缓冲区，`ends` 插入一个空字符然后刷新缓冲区

`unitbuf` 告诉流接下来每次写操作后都进行一次 `flush` 操作，另有 `nounitbuf` 使流恢复正常的刷新机制

**如果程序崩溃，则输出缓冲区不会被刷新**

如果一个输入流被关联到一个输出流，则任何试图从输入流读数据的操作都会先刷新关联的输出流，**交互系统通常应关联输入流和输出流**，以此确保所有输出都会在读操作前被打印出来

`tie()` 有两个重载的版本，它们都返回：如果本对象当前关联到一个输出流，则返回指向这个流的指针，否则返回空指针。两个重载版本的区别在于：一个不接受参数，另一个接受一个指向 `ostream` 的指针，第二个版本将自己关联到此 `ostream`

一旦一个文件流打开，它就保持与对应文件的关联，为了将文件流关联到另一个文件，必须先关闭已经关联的文件，另外当一个 `fstream` 对象被销毁时，`close` 会被自动调用

文件流有 6 种文件模式，每个文件流类型都定义了一个默认的文件模式，未指定文件模式时就用此默认模式：如与 `ifstream` 关联的文件默认以 `in` 模式打开

默认情况下，打开一个 `ofstream` 时（默认以 `out` 模式打开），文件的内容会被丢弃，除非同时指定 `app` 模式

补充：

- 条件状态 `P279 - P281`
- 文件模式 `P286 - P287`

### 第 9 章 顺序容器

容器有好多种，这里先说顺序容器：所有顺序容器都有快速顺序访问元素的能力，只是在不同的方面有性能折中：要么是向容器中添加或从容器中删除元素的代价，要么是非顺序访问容器中元素的代价

`vector` 是可变大小数组，除非有很明确的理由用别的，否则就用这个，支持快速随机访问，在尾部之外的地方插入或删除元素可能很慢；`deque` 双端队列，头尾插入 / 删除很快；`list` 双向链表，只支持双向顺序访问，任何位置插入 / 删除都很快；`forward_list` 单向链表，比较特殊，很多容器类的操作它都没有（但是有一些自己独有的，标准库里有这个容器主要是为了达到与最好的手写链表相当的性能……）`array` 固定大小数组，比刚才那个还特殊，一会单拎出来说；`string` 某种意义上就是字符串，作为一种容器和 `vector` 差不多，有自己的（字符串相关）特殊操作

注意：依实际需要选择容器类型。比如又需要输入时在中间位置插入元素，之后又需要随机访问元素，可以考虑先插入 `vector` 再排序，或者插入到 `list` 中再拷贝到 `vector` 里。再次重申：**不知道用啥就用 `vector`**

顺序容器几乎可以保存任意类型的元素（比如元素是另一种容器），但并不是所有的操作都能适用，比如用 `<` 操作符比较同类型容器时如果元素没有实现 `<` 那就不能比

`forward_list` 不支持递减运算符（单向链表只能往前走）

迭代器：要么指向容器中的某一元素，要么指向尾元素之后的位置，一个迭代器范围由两个属于同一容器的迭代器组成，是左闭右开区间

每个容器都定义了很多类型，如 `size_type`、`iterator`、`const_iterator` 等，除此之外还有反向迭代器（和迭代器各操作相反）等，另外还有些类型别名，如 `value_type` ，用于泛型编程

`begin` 和 `end` 操作生成指向容器中第一个元素和尾元素之后位置的迭代器，这俩玩意有很多版本：带 c 的返回 `const` 迭代器，带 r 的返回反向迭代器，如下：

```cpp
list<string> a = {"Shen", "Yuan", "CNPASS"};
auto it1 = a.begin();    // list<string>::iterator
auto it2 = a.rbegin();   // list<string>::reverse_iterator
auto it3 = a.cbegin();   // list<string>::const_iterator
auto it4 = a.crbegin();  // list<string>::const_reverse_iterator
```

另外，不以 c 开头的都是重载过的。非常量对象调用时返回普通迭代器，常量对象调用时返回 `const` 迭代器。与指针和引用类似，普通迭代器可以转换为对应的 `const` 迭代器，但是反过来不行

c 开头的版本主要是为了配合 `auto` 使用：不管对象是不是常量都返回 `const` 迭代器

所有容器类型都定义了一个默认构造函数，除 `array` 外都会创建一个指定类型的空容器

将一个新容器创建为另一个容器的拷贝有两种方法：直接拷贝整个容器，或（`array` 除外）拷贝一对迭代器指定的范围。前一种方法容器类型和元素类型必须都匹配，后一种方法容器类型无所谓，元素类型只要能转换就行，比如下面这样完全 OK：

```cpp
vector<const char*> a = {"Fuck", "C++", "grammar"};
forward_list<string> b(a.begin(), a.end());
```

顺序容器（又是除 `array` 外）还提供另一个构造函数：接受一个容器大小和一个（可选的）元素初始值。如果不提供元素初始值，则标准库会创建一个值初始化器（*注：值初始化：内置类型全是 0，类类型由类默认初始化*）

与内置数组一样，大小是 `array` 类型的一部分，所以一个默认构造的 `array` 是非空的：它包含了与其大小一样多的元素，这些元素都被默认初始化（*注：默认初始化：即变量被赋予默认值，具体是什么由变量类型决定，另外定义变量的位置也对此有影响，如函数体内的内置类型变量将不被初始化。* 对于类类型来说，每个类各自决定其初始化对象的方式，是否允许不经初始化就定义对象也由类决定：如果类允许这种行为，它将决定对象的初始值是什么）

与内置数组类型不同的是：`array` 支持拷贝和对象赋值操作（但是不能用花括号包围的值列表赋值，也不支持 `assign`）

**赋值运算符要求左右两边的运算对象有相同的类型。** 所以顺序容器（除 `array` 外）还定义了一个名为 `assign` 的成员，允许我们从一个不同但 **相容** 的类型赋值，或从容器的一个子序列赋值：`assign` 操作用参数所指定元素的拷贝替换左边容器中的所有元素

**传递给 `assign` 的迭代器不能指向调用 `assign` 的容器**

`swap` 有两个版本：成员函数和非成员函数的，由于非成员函数的版本在泛型编程中使用极广，所以最好统一 **使用非成员版本的 `swap`**

除 `array` 外（又特么是你）`swap` 不对任何元素进行拷贝 / 删除 / 插入操作，保证在常数时间内完成——元素本身并未交换，`swap` 只交换两个容器的内部数据结构——所以，除 `string` 外指向容器内元素的迭代器、引用、指针在 `swap` 后不会失效，只不过它们现在指向了 `swap` 后的另一个容器里的对应元素（指向的地址没变的意思）

`forward_list` 不支持 `size` 操作

所有容器都支持相等 / 不等运算符，除了无序关联容器外的所有容器都支持关系运算符（那四个比大小的），关系运算符两边必须是保存着相同类型元素的相同类型的容器

比较两个容器实际上是进行元素的逐对比较（与 `string` 类似，不再赘述），注意 **只有当元素类型也定义了相应的比较关系运算符时，才可以用关系运算符比较两个容器**

容器的相等 / 不等运算符是用元素的 `==` 运算符实现的，其他关系运算符是用元素的 `<` 运算符实现的

除 `array` 外所有标准库容器都可以在运行时动态添加或删除元素来改变容器大小，注意：**向一个 `vector`、`string`、`deque` 插入元素会使所有指向容器的迭代器、引用和指针失效**

除了 `array` 和 `forward_list` 每个顺序容器都支持 `push_back`

`list`、`forward_list`、`deque` 还支持 `push_front`

注意：**容器元素是拷贝**：即将一个对象插入到容器中时，事实上放进去的是对象值的一个拷贝，而非对象本身

`vector`、`deque`、`list`、`string` 还支持 `insert` 成员（`forward_list` 支持一个特殊版本：`insert_after`），可以向指定位置插入（一个范围内的）元素，返回指向被插入的第一个元素的迭代器

`emplace_front`、`emplace`、`empalce_back` 分别对应 `push_front`、`insert`、`push_back`：后三者接受元素类型的对象，并拷贝进容器中；前三者将参数传递给元素类型的构造函数，并在容器管理的内存空间中直接构造元素

每个顺序容器都有一个 `front` 成员函数，除 `forward_list` 之外的顺序容器都有一个 `back` 成员函数，这两个操作分别返回首元素和尾元素的 **引用**（注：**在容器中访问元素的成员函数，即 `front`、`back`、下标和 `at` 返回的都是引用**：`const` 的容器就返回 `const` 的引用，非 `const` 的容器就返回普通引用），**使用 `auto` 时要注意**，示例如下：

```cpp
if (!c.empty()) {
  c.front() = 42;      // 将 42 赋予 c 中的第一个元素
  auto &v = c.back();  // 获得指向最后一个元素的引用
  v = 1024;            // 改变 c 中的元素
  auto v2 = c.back();  // v2 不是一个引用，它是 c.back() 的一个拷贝
  v2 = 0;              // 未改变 c 中的元素
}
```

编译器不检查下标越界，但如果使用 `at` 成员函数，会在越界时抛出一个 `out_of_range` 异常

删除元素的成员函数并不检查其参数

**删除操作后，指向 `vector` 或 `string` 中删除点之后位置的迭代器、引用和指针都会失效**

**删除 `deque` 中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效**

`erase` 成员函数从容器中的指定位置删除（一定范围的）元素，返回指向被删除的最后一个元素之后位置的迭代器

**特殊的来了**：`forward_list` 没有 `insert`、`emplace`、`erase` 操作，而是有 `insert_after`、`emplace_after`、`erase_after`，另外它还有一个 `before_begin` 成员函数，返回一个指向首元素之前位置的 **首前迭代器**（是的 `const` 版本也有），以便于执行上述三种操作

`resize` 可以改变容器大小：增大缩小都可以。如果缩小，容器的后边的元素会被删除掉，如果增大，会将新元素添加到容器后部。一如既往的， `array` 不支持这个操作

`resize` 接受一个可选的元素值参数，用以初始化添加到容器中的元素：如果调用者未提供此参数，则执行值初始化（就是说，如果容器保存的是类类型元素，且 `resize` 向容器中添加新元素，则必须提供初始值，或元素类型必须提供一个默认构造函数）

**如果 `resize` 缩小容器，则指向被删除元素的迭代器、引用和指针失效**

**对 `vector`、`string` 或 `deque` 进行 `resize` *可能* 导致迭代器、指针和引用失效**

**注意：切记要保持迭代器有效，必须保证每次改变容器的操作之后都能正确地重新定位迭代器。这个建议对 `vector`、`string` 和 `deque` 尤其重要**

接上条，示例：如果在一个循环中插入 / 删除 `vector`、`string` 或 `deque` 中的元素，**不要缓存 `end` 返回的迭代器**

关于容器的容量管理，有这么几个相关的成员函数：`size` 指已经保存的元素的数量（下略作 ”大小“），`capacity` 指在不分配新的内存空间的前提下最多能保存多少元素（下略作 ”容量“），`reserve` 分配容量，`shrink_to_fit` 将容量缩减到与大小相当

`shrink_to_fit` 只适用于 `vector`、`string` 和 `deque`，用以要求退回不需要的内存空间，但是**具体实现可以选择忽略此请求**

`capacity` 和 `reserve` 只适用于 `vector` 和 `string`，`reserve` 不改变容器中元素的数量，它仅影响容量，而且：**只有需求大于当前容量时它才分配内存空间，且有可能给的比要的更大；否则狗屁不干，当然也不会退回内存空间。**（注：类似的，`resize` 也不影响容量）

`vector` 这玩意有高效的扩张策略，但仅在迫不得已时才分配新的内存空间，**一般来说是容量翻倍**

除了顺序容器，标准库还定义了三个顺序容器适配器：`stack`、`queue` 和 `priority_queue`（注：适配器是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另一种事物一样）

适配器可以使用一个类型参数，也可以使用两个类型参数，第二个参数用来指定适配器是由哪种容器实现的，如下：

```cpp
stack<int> stk;
stack<string, vector<string>> str_stk;
```

对于一个给定的适配器，可以使用哪些容器是有限制的：默认情况下 `stack` 和 `queue` 基于 `deque`，`priority_queue` 基于 `vector`

补充：

- `string` 特有的额外操作 `P320 - P328`

### 第 10 章 泛型算法

容器本身只定义了很少的操作，其他的都是靠标准库里的一组泛型算法，这组算法大多数定义于头文件 `algorithm` 中，可以用于容纳不同元素的不同容器类型（甚至有的不是容器类型的序列也可以，没错说的就是你，内置数组）

泛型算法使用迭代器操作实现，它们不依赖于容器，但依赖于元素类型的操作，如 `find` 运用元素类型的 `==` 运算符来完成每个元素与给定值的比较

注意：**泛型算法本身不会执行容器的操作**，它们只会运行于迭代器之上，执行迭代器的操作，由此我们可以得知：**泛型算法永远不会改变底层容器的大小**，即使改变了，也是因为使用了特殊的插入迭代器：改变容器大小的是插入迭代器，而非算法本身

有一些算法从两个序列中读取元素，这些算法并不要求元素类型或容器类型相同，只要能进行对应的操作即可

**对于那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少和第一个一样长**

如上条所述，算法不检查写操作，如果要保证算法有足够的元素空间来容纳输出数据，则需使用插入迭代器，用以向容器中插入元素。示例中使用了定义于 `iterator` 中的 `back_inserter` 函数：

```cpp
vector<int> vec;               // 空向量
auto it = back_inserter(vec);  // 通过它赋值会将元素添加到 vec 中
*it = 42;                      // vec 中现在有一个元素，值为 42
fill_n(it, 10, 0);             // 添加 10 个元素到 vec
```

拷贝（`copy`）算法接受三个迭代器，前两个表示输入范围，第三个表示目的序列的起始位置：

```cpp
int a1[] = {0, 1, 2, 3, 4};
int a2[sizeof(a1) / sizeof(*a1)];  // a2 与 a1 大小一样
// ret 指向拷贝到 a2 的尾元素之后的位置
auto ret = copy(begin(a1), end(a1), a2);  // 把 a1 的内容拷贝给 a2
```

许多算法都提供所谓的“拷贝”版本，它们保留原序列不变，将结果保存到其他位置：

```cpp
// 将所有值为 0 的元素改为 42
replace(ilist.begin(), ilist.end(), 0, 42);
// 下述操作后 ilist 并未改变，ivec 包含 ilist 的一份拷贝
// 只不过原来值为 42 的元素被改为 0
replace_copy(ilist.cbegin(), ilist.cend(), back_inserter(ivec), 42, 0);
```

还有一些用来排序的算法，以下是一个消除重复单词的简单示例：

```cpp
void elimDups(vector<string> &words) {
  // 按字典序排序 words，以便查找重复单词
  sort(words.begin(), words.end());
  // unique 重排输入范围，使得每个单词只出现一次
  // 排列在范围的前部，返回指向不重复区域之后一个位置的迭代器
  auto end_unique = unique(words.begin(), words.end());
  // 使用向量操作 erase 删除重复单词
  words.erase(end_unique, words.end());
}
```

算法可以定制操作，如 `sort` 算法默认使用元素类型的 `<` 运算符，但我们可以重载 `sort` 的默认行为来使其按我们需要的方式排序：`sort` 接受一个谓词作为第三个参数（*注：谓词：一个可调用的表达式，其返回结果是一个能用作条件的值。* 标准库算法使用的谓词有只接受单一参数的 **一元谓词** 和接受两个参数的 **二元谓词** 两种）

注：可调用对象有四种：函数，函数指针，重载了函数调用运算符的类，lambda 表达式

根据算法接受一元 / 二元谓词，传递给算法的谓词必须严格接受一个 / 两个参数，为回避此限制可使用 lambda 表达式：一个 lambda 表达式表示一个可调用的代码单元，可理解为一个可以定义在函数内部的未命名的内联函数。一个 lambda 表达式具有如下形式：

```cpp
[capture list] (parameter list) -> return type { function body }
```

其中，capture list（捕获列表）是一个 lambda 所在函数中定义的局部变量的列表（通常为空），后面三个和普通函数一样，除了 lambda 必须使用尾置返回

捕获列表和函数体必须要有，参数列表和返回类型可以不写。忽略参数列表就等于指定一个空参数列表，忽略返回类型时：如果函数体只有一个 return 语句，则返回类型由此推断而来，**否则返回类型为 `void`**

lambda 不能有默认参数

注意：**定义一个 lambda 时，编译器生成一个与 lambda 对应的新的（未命名的）类类型**：当向一个函数传递一个 lambda 时，同时定义了一个新类型和该类型的一个对象，传递的参数就是这个类类型的未命名对象。类似的，用 auto 定义一个用 lambda 初始化的变量时，定义了一个从 lambda 生成的类类型的对象

**默认情况下，从 lambda 生成的类都包含一个对应该 lambda 所捕获的变量的数据成员，该数据成员在 lambda 对象创建时被初始化**

关于捕获列表：一个 lambda 只有在其捕获列表中捕获一个它所在函数中的局部（非 `static`）变量，才能在函数体中使用该变量。**局部 `static` 变量和它所在函数之外声明的名字可以直接用**

lambda 的捕获也分两种：值捕获和引用捕获，用法和要点与函数传值 / 传引用一样：注意变量的生命周期，返回引用同理（注：**尽量保持 lambda 的变量捕获简单化**）

lambda 还有隐式捕获，写个 `=` 表示值捕获，`&` 表示引用捕获，示例如下：

```cpp
// sz 为隐式捕获，值捕获方式
auto wc = find_if(words.begin(), words.end(),
                  [=](const string &s) { return s.size() >= sz; });
```

还可以混合使用（干，我可算知道为什么说 C++ 是一门被过度设计的语言了）：

```cpp
void biggies(vector<string> &words, vector<string>::size_type sz,
             ostream &os = cout, char c = ' ') {
  // os 隐式捕获，引用捕获方式；c 显式捕获，值捕获方式
  for_each(words.begin(), words.end(),
           [&, c](const string &s) { os << s << c; });
  // os 显式捕获，引用捕获方式；c 隐式捕获，值捕获方式
  for_each(words.begin(), words.end(),
           [=, &os](const string &s) { os << s << c; });
}
```

混合使用隐式 / 显式捕获的时候：捕获列表的第一个元素必须是 `&` 或 `=`，此符号指定了默认捕获方式为引用或值。此外，**显式捕获的变量必须使用与隐式捕获不同的方式**

注意：上例代码中 `c` 或 `&os` 的位置事实上是一个逗号分隔的列表，包含 0 个或多个来自所在函数的变量。特别的，**隐式值捕获、显式引用捕获的情况时，引用捕获列表中的名字不能包括 `this`**

可变 lambda（可修改被捕获的变量的 lambda）分两种：值捕获的，在参数列表后边加上 `mutable`；引用捕获的，一如既往，能不能修改看它引用的是不是 `const`

再次重申：**lambda 这玩意除了单一 return 语句的可以自动推断返回类型，剩下的都默认返回 `void`，想指定返回类型得用尾置返回类型**

除了为每个容器定义的迭代器外，标准库还在 `iterator` 里定义了四种迭代器：插入迭代器，流迭代器，反向迭代器，移动迭代器

插入器：是一种迭代器适配器，接受一个容器，生成一个插入迭代器来向给定容器中添加元素

插入器有三种：`back_inserter`、`front_inserter`、`inserter`（当然了只有容器支持对应的 `push_back` 等操作你才能用……）`back_inserter` 往容器尾部插入，`front_inserter` 往容器头部插入，`inserter` 接受两个参数，第二个是个迭代器，它把元素插入到此迭代器之前的位置

**注意：`front_inserter` 的行为和另外两个不一样：往容器的首元素之前再插入一个元素，原来那个就不再是容器的首元素了，所以 `front_inserter` 生成的插入迭代器会将元素的插入顺序反过来，而另外两个则不会**

`iostream` 类型不是容器，但标准库定义了可以用于这类 IO 类型对象的迭代器，用法差不太多，有个小细节在于：`istream_iterator<T> end;` 可以直接读取类型为 T 的 `istream_iterator` 迭代器用于表示尾后位置，`ostream_iterator` 则没有这玩意，但可以 `ostream_iterator<T> out (os, d);`，其中 `d` 指向一个空字符结尾的字符数组（就是 C 风格字符串），在每个值后面都输出一个 `d`

反向迭代器：就是反着来的迭代器……也有那一大堆 c 或 r 开头的版本，但 **反向迭代器只能由既支持 `++` 又支持 `--` 的迭代器定义而来，所以 `forward_list` 和流迭代器没有对应的反向迭代器**

反向迭代器真的是反着走的……这么设计主要是为了直接把反向迭代器丢到算法里就能得到相反的结果，但是 **注意反向迭代器的 `rbegin` 到 `rend` 也是左闭右开区间**，所以它们和迭代器并不是一一对应，而是错开一位的。另外由于走向相反，**搭配迭代器使用的时候需要调用 `base` 成员函数来将其转换为对应的普通迭代器**（这个时候不用考虑错一位的问题）

特殊的：对于两个链表类型 `list` 和 `forward_list`，它们定义了独有的 `sort`、`merge`、`reverse` 和 `unique`（理由是通用版本的算法用于链表时代价太高，于是实现了性能更好的链表版本），此外还定义了链表特有（其他容器没有）的 `splice` 算法

链表特定算法与通用算法的区别在于：链表版本会改变底层的容器，如 `remove` 会删除（而不是覆盖）指定的元素；`unique` 会删除第二个和后继的重复元素；`merge` 和 `splice` 则会销毁其参数：来自两个链表中的元素仍然存在，但它们都已在同一链表中

补充：

- 参数绑定 `P354 - P357`
- `iostream` 迭代器 `P359 - P362`
- 泛型算法结构 `P365 - P369`

### 第 11 章 关联容器

关联容器按 3 个维度分成 8 种：是一个 `map` 或 `set`，`map` 中的元素是键值对，`set` 里只有关键字（以下略作键）；允许或不允许重复键，允许重复的容器的名字中都包含单词 `multi`；按顺序或不按顺序保存元素，其中无序容器都以 `unordered` 开头，并使用哈希函数组织元素

`map` 和 `multimap` 定义在头文件 `<map>` 中，`unordered_map` 和 `unordered_multimap` 定义在头文件 `<unordered_map>` 中，那四种 `set` 类似

关联容器不支持顺序容器那种位置相关的操作（比如 `push_back` 之类的）

关联容器的迭代器都是双向的

关联容器对其关键字类型有一些限制：对于四种有序容器来说，关键字类型必须定义元素的比较方法，默认情况下标准库使用关键字类型的 `<` 运算符来比较两个关键字；无序容器下面另写

接上条，插一嘴：传递给排序算法的可调用对象也得满足和关联容器中关键字一样的类型要求

可以提供自己定义的操作来代替关键字上的 `<` 运算符：所提供的操作必须在关键字类型上定义一个 *严格弱序*，但是这玩意解释起来太麻烦了就理解成小于等于就行了，或者，**在实际编程中，如果一个类型定义了 “行为正常” 的 `<` 运算符，则它可以用作有序关联容器的关键字类型**

用来组织一个容器中元素的操作的类型也是该容器类型的一部分，要在定义关联容器类型时提供此操作的类型，如下例所示：

```cpp
struct Book {
  int isbn;
};

bool compareBook(const Book &lhs, const Book &rhs) {
  return lhs.isbn < rhs.isbn;
}

multiset<Book, decltype(compareBook) *> bookstore(compareBook);
// 注：decltype() 返回实际类型，加上 * 来获取指针类型
//     后面的函数名字会自动转换成指针，当然写 &compareBook 也是一样的
```

`pair` 这个类型：定义在头文件 `<utility>` 中，保存两个数据成员。与容器类似，`pair` 是一个用来生成特定类型的模板，定义一个 `pair` 时要提供两个类型名（不要求一样），其数据成员具有对应的类型，**`pair` 的默认构造函数对其数据成员进行值初始化**

`.first` 和 `.second` 分别返回一个 `pair` 的第一个 / 第二个（公有）数据成员

`pair` 的大小关系按字典序，依赖元素的 `<` 运算符来实现：当 `p1.first < p2.first`，或 `!(p1.first < p2.first) && p1.second < p2.second` 时，`p1 < p2` 为 `true`

当 `first` 和 `second` 成员分别相等时，两个 `pair` 相等

`make_pair` 可用来生成 `pair` 对象，作函数返回值时亦可对返回值进行列表初始化，如下：

```cpp
pair<string, int> process(vector<string> &v) {
  // 处理 v

  if (!v.empty()) {
    return {v.back(), v.back().size()};  // 列表初始化
    // return pair<string, int>(v.back(), v.back().size());
    // return make_pair(v.back(), v.back().size());
    // 以上 3 种写法等价
  } else {
    return pair<string, int>();  // 隐式构造返回值
  }
}
```

关联容器有三种额外的类型别名：`key_type`（键的类型），`mapped_type`（值的类型，四种 `map` 才有），`value_type`（对 `set` 来说，和 `key_type` 一样；对 `map` 来说，为 `pair<const key_type, mapped_type>`，注：由于我们不能改变一个元素的关键字，所以这些 `pair` 的关键字部分是 `const` 的）

解引用一个关联容器迭代器时，会得到一个类型为容器的 `value_type` 的值的引用，**再次强调：那四种 `map` 的 `value_type` 是一个 `pair` ，我们可以改变 `pair` 的值，但是不能改变关键字成员的值**

四种 `set` 的迭代器是 `const` 的：不管是 `iterator` 类型还是 `const_iterator` 类型，都只允许只读访问 `set` 中的元素，即 `set` 中的键也是 `const` 的

关联容器也支持 `begin` 和 `end` 操作

迭代器按关键字升序遍历有序关联容器

一般不对关联容器使用泛型算法，因为键是 `const` 意味着不能将关联容器传递给修改或重排元素的算法（所以顶多也就是用用 `copy`）

关联容器有一个名为 `find` 的成员，它通过一个给定的关键字直接获取元素，相比于顺序查找的泛型 `find` 算法要快很多

关联容器也有 `insert` 和 `emplace` 操作，和顺序容器的差不多不细写了

**注意：向四种 `map` 中进行 `insert` 操作时，元素类型是 `pair`**

**特殊的：对于非 `multi` 的关联容器，添加单一元素的 `insert`（或 `emplace`，下略）返回一个 `pair`**，其 `first` 成员是一个迭代器，指向具有给定关键字的元素，`second` 成员是一个 `bool` 值，支出元素是插入成功还是已经存在于容器中：如果键已存在，则 `insert` 什么也不做，那个 `bool` 值是 `false`，如果键不存在，那就插入，那个 `bool` 值是 `true`

关联容器三个版本的 `erase` 也跟顺序容器的差不多不细写了（好耶），但关联容器还提供一个额外的 `erase`，这个得写（不好耶）：它接受一个 `key_type` 参数，删除所有匹配给定键的元素（如果存在的话），返回实际删除的元素的数量（也就是说对非 `multi` 的关联容器执行这个操作总返回 0 或 1）

`map` 和 `unordered_map` 提供下标运算符和一个对应的 `at` 函数（四种 `set` 没有是因为没有值，另外两种 `map` 没有是因为一个键可能对应多个值）

先说 `at`：带参数检查，键不存在就抛出一个 `out_of_range` 异常

**`map` 和 `unordered_map` 的下标运算符有两个特殊的地方：其一是如果键不存在，那就插入一个新的进去**（所以只能对非 `const` 的 `map` 或 `unordered_map` 使用下标操作）；**其二是它返回的类型和迭代器解引用出来的类型不一样**（对其他支持下标运算符的容器来说是一样的）：在这里，解引用迭代器返回一个 `value_type` 对象，而下标运算符返回一个 `mapped_type` 对象

关联容器提供多个查找一个指定元素的方法，最简单的两个是 `find` 和 `count`（对 `multi` 的关联容器，`count` 会做计数工作，所以如果无需计数还是用 `find`），如下：

```cpp
set<int> iset = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
iset.find(1);    // 返回一个迭代器，指向 key == 1 的元素
iset.find(11);   // 返回一个迭代器，其值等于 iset.end()
iset.count(1);   // 返回 1
iset.count(11);  // 返回 0
```

由于 `map` 和 `unordered_map` 的下标运算符有严重的副作用，所以如果想查找键值对而不想改变该 `map` 和 `unordered_map`，应该使用 `find`：

```cpp
if (word_count.find("foobar") == word_count.end())
  cout << "foobar is not in the map" << endl;
```

**如果一个 `multimap` 或 `multiset` 中有多个元素具有给定关键字，那么这些元素在容器中会相邻存储（无序版本的那两个也是）**

基于上条，我们有：`lower_bound(k)`，返回一个迭代器，指向第一个关键字不小于 k 的元素，`upper_bound(k)`，返回一个迭代器，指向第一个关键字大于 k 的元素，`equal_range(k)`，返回一个迭代器 `pair`，表示关键字等于 k 的元素的范围，若 k 不存在，则 `pair` 的两个成员都等于 `end()`

四种无序容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的 `==` 运算符

无序容器在存储上组织为一组桶，每个桶保存零或多个元素，无序容器使用一个哈希函数将元素映射到桶。另外如果容器允许重复键，则具有相同键的元素会在一个桶里。无序容器还提供了一组管理桶的函数

无序容器对元素的键类型要求很特殊：无序容器使用键的 `==` 运算符来比较元素，还使用一个 `hash<key_type>` 类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了 `hash` 模板，还为 *一些* 标准库类型（`string` 和智能指针）定义了 `hash`，因此我们可以定义关键字是内置类型、`string` 和智能指针的无序容器，但 **不能直接定义键类型是自定义类类型的无序容器**：不能直接使用 `hash` 模板，而必须提供自己的 `hash` 模板版本（见笔记第 III 部分的模板特例化）

接上条：类似于为有序容器重载键类型的默认比较操作，也可以提供函数来代替 `==` 运算符和哈希值计算函数，如下：

```cpp
struct Book {
  int isbn;
};

size_t hasher(const Book &book) { return hash<int>()(book.isbn); }

bool areSameBook(const Book &lhs, const Book &rhs) {
  return lhs.isbn == rhs.isbn;
}

using Book_multiset =
    unordered_multiset<Book, decltype(hasher) *, decltype(areSameBook) *>;

Book_multiset bookstore(42, hasher, areSameBook);
```

接上条：如果类定义了 `==` 运算符，可以只重载哈希函数

补充：

- 严格弱序 `P378`
- 访问元素 `P388 - P391`
- 无序容器管理操作 `P395`