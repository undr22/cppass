### 第 8 章 IO 库

IO 库对应三个头文件：`<iostream>`、`<fstream>` 和 `<sstream>`，后两者中的类对应着继承自 `<iostream>`，如 `ifstream` 和 `istringstream` 都继承自 `istream`

IO 对象不能拷贝或赋值，所以一般以引用方式传递和返回流，另外读写一个 IO 对象会改变其状态，所以引用也不能是 `const` 的

IO 类定义了一些函数和标志，用来访问和操作流的条件状态，四种状态中：bad 指流已崩溃、fail 指 IO 操作失败、eof 指流到达了文件结束、good 指流处于未出错状态，它们各自对应一个 `iostate` 类型的 `constexpr` 值，发生对应错误时会将对应的值置位

可以将流作为条件来判断其状态：其中流的状态为 bad、fail、eof 时会（额外）将 fail 置位，所以将流用作条件的代码就等于 `!fail()`，而 bad 和 eof 只能表示特定的错误

每个输出流都有一个缓冲区，可能刷新缓冲区的原因如下：

- 程序正常结束
- 缓冲区满
- 使用操作符（如 `endl`）显示刷新缓冲区
- 使用 `unitbuf` 操作符设置接下来每次操作流后都刷新缓冲区，如 `cerr` 就默认是这种设置
- 一个输出流可能被关联到另一个流，此种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新，例如默认状态下 `cin` 和 `cerr` 都关联到 `cout`，因此读 `cin` 或写 `cerr` 都会导致 `cout` 的缓冲区被刷新

`flush` 刷新缓冲区，`endl` 换行并刷新缓冲区，`ends` 插入一个空字符然后刷新缓冲区

`unitbuf` 告诉流接下来每次写操作后都进行一次 `flush` 操作，另有 `nounitbuf` 使流恢复正常的刷新机制

**如果程序崩溃，则输出缓冲区不会被刷新**

如果一个输入流被关联到一个输出流，则任何试图从输入流读数据的操作都会先刷新关联的输出流，**交互系统通常应关联输入流和输出流**，以此确保所有输出都会在读操作前被打印出来

`tie()` 有两个重载的版本，它们都返回：如果本对象当前关联到一个输出流，则返回指向这个流的指针，否则返回空指针。两个重载版本的区别在于：一个不接受参数，另一个接受一个指向 `ostream` 的指针，第二个版本将自己关联到此 `ostream`

一旦一个文件流打开，它就保持与对应文件的关联，为了将文件流关联到另一个文件，必须先关闭已经关联的文件，另外当一个 `fstream` 对象被销毁时，`close` 会被自动调用

文件流有 6 种文件模式，每个文件流类型都定义了一个默认的文件模式，未指定文件模式时就用此默认模式：如与 `ifstream` 关联的文件默认以 `in` 模式打开

默认情况下，打开一个 `ofstream` 时（默认以 `out` 模式打开），文件的内容会被丢弃，除非同时指定 `app` 模式

补充：

- 条件状态 `P279 - P281`
- 文件模式 `P286 - P287`