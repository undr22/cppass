### 第 2 章 变量和基本类型

为了避免重复定义，`const` 对象仅在文件内有效：当多个文件中出现了同名的 `const` 对象时，其实是分别在不同文件中定义了独立的变量。如果想使用跨文件的 `const` 对象，则需要在声明和定义前都加上 `extern` 关键字

顶层 `const` 描述的是对象本身，底层 `const` 则说的是指针或引用等复合类型的基本类型：执行拷贝操作时，顶层 `const` 并无影响，底层 `const` 则有限制：拷入和拷出的对象必须具有相同的 `const` 资格，或能够从非常量转换为常量

引用都是底层 `const`，指针有可能是顶层或底层 `const`

常量表达式：值不会改变且编译期间就能得到结果的表达式（比如字面值是常量表达式，用常量表达式初始化的 `const` 对象也是常量表达式）

在复杂系统中很难分辨一个初始值到底是不是常量表达式，于是可以将之声明为 `constexpr` 变量，将验证的工作交给编译器（一般来说如果觉得某个变量是常量表达式，就直接声明成 `constexpr` 就行）

如果用 `constexpr` 关键字声明了一个指针，则该指针是一个常指针（顶层 `const`），与指针所指的对象无关

如果 `decltype` 使用的表达式不是一个变量，则 `decltype` 返回表达式结果对应的类型（就比如 `i` 是个 `int` 类型的变量，那 `decltype(i)` 返回 `int`，`decltype((i))` 返回 `int&`），`decltype((variable))` 永远返回一个引用类型

预处理变量无视 C++ 语言中关于作用域的规则

### 第 3 章 字符串、向量和数组

理解复杂声明可以从内而外、再从右至左：

```cpp
int arr[10];             // arr 是 int 类型的数组
int *ptrs[10];           // ptrs 是数组，内含 10 个 int 类型的指针
int(*Parray)[10] = &arr; // Parray 指向一个 int 类型的数组
int(&arrRef)[10] = arr;  // arrRef 引用一个 int 类型的数组
int *(&arry)[10] = ptrs; // arry 是数组的引用，该数组含有 10 个 int 类型的指针
```

数组的下标是 `size_t` 类型，`size_t` 是一种机器相关的无符号类型，足够大到表示内存中任意对象的大小，定义于 `cstdeff` 头文件

大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针

内置的下标运算符所用的索引值不是无符号类型，这一点区别于标准库。即如果使一个指针指向数组中间位置的元素，则 `[]` 中可以出现负数（别越界就行）

要使用范围 `for` 语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型（为了防止被自动转换成指针）

### 第 4 章 表达式

左值是对象，右值是变量的内容。或者说：当一个对象被用作右值时，用的是对象的值（内容），当对象被用作左值时，用的是对象的身份（在内存中的位置）

使用 `decltype` 的时候左值和右值也有所不同：如果表达式的求值结果是左值，`decltype` 作用于该表达式（不是变量）得到一个引用类型

前置递增 / 递减运算符先改变操作对象，然后将改变之后的对象作为求值结果，后置版本的结果则是运算对象改变之前的副本

条件运算符（`?:`）允许嵌套

左移运算符（`<<`）在右边补 0，右移运算符（`>>`）的行为依赖类型：如果是无符号类型就补 0，有符号类型就补符号位

`sizeof` 运算符返回一个 `size_t` 类型的值，后面是表达式的话就直接用就行，后面是类型名的话要在类型名外加括号

`sizeof` 不会真正求值，所以在 `sizeof` 的对象里解引用一个无效指针也完全 OK

隐式的类型转换中需要注意小的算术类型们：比如一个 `short` 类型的值 `+` 一个 `char` 类型的值，这俩都会被提升成 `int` 类型

`cast-name<type>(expression)` 里的 `type` 如果是引用类型则结果是左值

`static_cast`：除底层 `const` 外只要是有明确定义的类型转换都可以用这个

`const_cast`：只能改变对象的底层 `const`，经常用于有函数重载的上下文中

`reinterpret_cast`：为运算对象的位模式提供较低层次上的重新解释

### 第 5 章 语句

**`switch` 语句中的 `case` 标签必须是整形常量表达式**（意思就是什么 `3.14` 或者普通的变量都不行），另外任何两个 `case` 标签的值不能相同

如果某处一个带初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳到后一处的行为非法

### 第 6 章 函数

定义在函数体外的变量叫 “全局变量”，形参和定义在函数体内部的变量叫 “局部变量”。全局变量的生命周期是整个程序的执行过程，局部变量分两种：

对于普通的局部变量，函数的控制路径经过变量的定义语句时创建该变量，到达定义所在的块的末尾是销毁它，也叫 “自动对象”；另一种是将变量定义成 `static` 的 “局部静态对象”，在程序的执行路径第一次经过其定义语句时初始化，直到程序终止才被销毁

函数的返回值不能是数组或函数，但指向数组或函数的指针 OK

向函数传递一个数组时事实上传递的是指向数组首元素的指针（因为数组不允许拷贝）：

```cpp
// 下面三个 print 函数是等价的，形参类型都是 const int*
void print(const int *);
void print(const int[]);
void print(const int[10]);
```

向函数传递多维数组时，由于首元素本身就是一个数组，所以数组第二维（和之后的所有维度）的大小都是类型的一部分，不能省略

向 `main` 函数传递参数时：

```cpp
int main(int argc, char *argv[]) { ... }
```

或：

```cpp
int main(int argc, char **argv) { ... }
```

第二个形参 `argv` 是个数组，元素是指向 C 风格字符串的指针，第一个形参 `argc` 是数组中字符串的数量。当实参传给 `main` 函数后，`argv` 的第一个元素指向程序的名字或一个空字符串，接下来的元素依次传递命令行提供的实参，最后一个指针指向 0（比如传 2 个参数进去，那这个 `argv` 一共有 4 个元素，`argc` 等于 3）

`initializer_list` 是一种标准库模板类型，用于向函数传一组相同类型的参数，用法和 `vector` 差不多：区别在于该类型对象中的元素永远是常量值，无法修改

返回一个值的方式和初始化一个变量或形参一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果

调用一个返回引用的函数得到左值，其他返回类型得到右值

对比较复杂的返回类型可以使用尾置返回类型或 `decltype`：

```cpp
// func 接受一个 int 类型的实参，返回一个指针，该指针指向含有 10 个整数的数组
auto func(int i) -> int (*)[10];

int odd[] = {1, 3, 5, 7, 9};
int even[] = {0, 2, 4, 6, 8};
// 返回一个指针，该指针指向含有 5 个整数的数组
decltype(odd) *arrPtr(int i) {
    return (i % 2) ? &odd : &even; // 返回一个指向数组的指针
}
```

注意以上代码中：`decltype` 不负责把数组转换成对应的指针，其结果是个数组，所以想要表示 `arrPtr` 返回指针还得在函数声明时加一个 `*`

`main` 函数不能重载

因为顶层 `const` 不影响传入的函数的对象，所以不能基于一个形参有没有顶层 `const`重载函数

默认实参一般在声明中指定，并将声明放在头文件里

一旦某个形参被赋予了默认值，那它后面的所有形参都必须有默认值

`constexpr` 函数就是能用于常量表达式的函数，它的返回类型和所有形参类型都得是字面值类型，函数体之中必须有且只有一条 `return` 语句

`inline` 函数和 `constexpr` 函数可以在程序中多次定义（因为展开需要定义，仅声明不行），不过定义必须完全一致，为此这两种函数通常定义在头文件中

补充：

- 函数匹配 `P217 - P221`
- 函数指针 `P221 - P223`

### 第 7 章 类

成员函数的声明在类的内部，定义在内部和外部都 OK：定义在类内部的话会自动 `inline`

作为接口的非成员函数声明和定义都在类的外部，但声明应该和类放在同一个头文件中

`const` 成员函数的 `const` 事实上指的是 `this`：`this` 原本是一个常指针（顶层 `const`），加上这个后变成指向常量的常指针

编译一个类时先编译成员的声明，然后才轮到成员函数体（注意：不是先数据成员，再成员函数），所以成员函数体可以无视声明次序地使用类里的成员

在类的外部定义成员函数时，返回类型、函数名、参数列表都要和声明匹配（理所当然的 `const` 成员函数的那个 `const` 也算）

构造函数不能是 `const`，因为直到构造函数完成初始化过程，对象才真正取得 `const` 属性

不用提供参数的构造函数叫 “默认构造函数”（最好有一个）；编译器给的那个叫 “合成的默认构造函数”，只有当没有声明任何构造函数时才会提供

`= default` 可以要求编译器生成默认构造函数，写在参数列表后面、没有函数体。既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部：区别仅在于 `inline` 与否

友元那个 `friend` 开头的声明要放在类的内部（一般在类最开始的地方集中声明），且友元不受访问控制级别的约束。关于友元记住这个：**那个声明只说明了访问权限，而并非一个通常的声明**

友元除了那个 `friend` 开头的声明，还要再类外声明一次（这个声明一般在类的头文件里，为了使友元对类的用户可见）

类里也可以定义类型别名（使用 `typedef` 或 `using`），受访问控制级别约束（一般写在类的最前面，好保证所有使用该类型的成员都在类型别名定义后）

显式 `inline` 的时候 `inline` 写在声明和定义处都可以（都写也合法），但为了好理解一般写在定义的地方（`inline` 成员函数应和相应的类定义在同一个头文件中）（普通的 `inline` 函数也应该定义在头文件里，毕竟又短又小直接展开，没有内容展开个毛线）

数据成员前面加 `mutable` 代表可变：它永远也不会是 `const`，即使在 `const` 函数里也可以修改

类内初始值必须用 `=` 或 `{}` 来初始化

`const` 成员函数返回 `*this` 时返回的是常量引用，基于此可以重载成员函数：常量对象调用 `const` 的版本，非常量对象优先调用非 `const` 的版本

类可以先声明而不定义（即 “前置声明”），此时的类是一个不完全类型，可以定义这种类型的指针和引用，可以声明（而不能定义）以这种类型为参数或返回类型的函数（要点在于：**编译器需要知道该类型的对象占多大空间才能初始化**）

类也可以作为友元，而友元关系不具有传递性（每个类管理自己的友元）

类的成员函数也可以作为友元，但要仔细组织程序的结构以满足声明和定义的彼此依赖关系

构造函数尽量用初始值列表：一是效率高，二是如果类内成员有 `const` 或引用，则它们必须被初始化

成员的初始化顺序和声明顺序一致（而非构造函数的初始值列表顺序）

委托构造函数的初始值列表只有一个入口：即类名本身，类名后紧跟参数列表，参数列表必须与类中的另一个构造函数相匹配

当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行，然后控制权交还给委托者的函数体

如果有构造函数只接受一个实参，那它实际上定义了转换成此类类型的隐式转换机制，这种构造函数叫 “转换构造函数”（只允许一步转换）

构造函数前加上 `explicit` 可以阻止隐式转换（显式转换可以直接用类名构造或 `static_cast`）

类成员前加 `static` 就是静态成员，静态成员与类关联而非与对象关联，静态成员只存在一份，被所有此类对象共享，可以用 `::` 来访问（前边是类名），也可以用此类对象来访问

静态成员函数不和任何对象绑定，没有 `this` 指针，也不能是 `const` 的

静态成员函数的定义在类的内外皆可，但 `static` 关键字只能在类内的声明处写

静态数据成员不属于任何一个对象，所以不是构造函数初始化的，所以一般不在类内初始化

静态数据成员在类外定义，它的生命周期从定义持续到程序结束，其定义应该和其他非内联函数的定义放在一起

静态数据成员可以是不完全类型（也可以是它自己的类类型），静态成员也可以作为默认实参

补充：

- 默认初始化 / 值初始化的发生场景 `P262`
- 聚合类 / 字面值常量类 `P266 - P268`
- 静态成员的类内初始化 `P270 - P271`